---
phase: 06-equivalence-gate-determinism-and-triage
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/run_tests.sh
  - tests/fixtures/manifest.yaml
  - tests/README.md
autonomous: true
requirements:
  - REL-04
must_haves:
    truths:
      - Representative verify-equivalence outcomes are deterministic across repeated runs for x86/x64/arm.
      - Equivalence status semantics are tuple-based and stable (architecture, fixture, check, status, message).
      - Representative fixture scope remains manifest-governed and explicitly auditable.
    artifacts:
      - path: tests/run_tests.sh
        provides: Deterministic representative equivalence execution and normalized tuple result emission
      - path: tests/fixtures/manifest.yaml
        provides: Explicit representative fixture metadata used for deterministic equivalence scope
      - path: tests/README.md
        provides: Contributor guidance for deterministic equivalence reruns and scope interpretation
    key_links:
      - from: tests/run_tests.sh
        to: tests/fixtures/manifest.yaml
        via: Equivalence mode selects representative fixtures exclusively from manifest metadata
        pattern: ci_representative
      - from: tests/run_tests.sh
        to: tests/README.md
        via: Runner tuple outputs and rerun expectations are documented for contributor triage
        pattern: verify-equivalence
      - from: tests/README.md
        to: tests/fixtures/manifest.yaml
        via: Documentation links deterministic fixture scope to manifest ownership
        pattern: manifest
---

<objective>
Stabilize representative equivalence harness behavior so outcomes are deterministic and auditable.

Purpose: deliver the REL-04 foundation by normalizing fixture scope, ordering, and status tuple semantics.
Output: deterministic verify-equivalence runner path with explicit representative governance.
</objective>

<execution_context>
@/Users/maleick/.codex/get-shit-done/workflows/execute-plan.md
@/Users/maleick/.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/06-equivalence-gate-determinism-and-triage/06-RESEARCH.md
@tests/run_tests.sh
@tests/fixtures/manifest.yaml
@tests/README.md

No phase CONTEXT.md exists; use milestone constraints from PROJECT/STATE/RESEARCH.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Normalize representative fixture selection and ordering for equivalence mode</name>
  <files>tests/run_tests.sh
tests/fixtures/manifest.yaml</files>
  <action>Refine verify-equivalence fixture selection to ensure deterministic ordering and explicit representative eligibility rules from manifest metadata, failing early when representative metadata is incomplete or ambiguous.</action>
  <verify><automated>bash tests/run_tests.sh --mode verify-equivalence --arch all --artifacts-dir ci-artifacts/phase6-ordering</automated></verify>
  <done>Representative fixture scope and execution ordering are deterministic and manifest-auditable for all supported baseline architectures.</done>
</task>

<task type="auto">
  <name>Task 2: Normalize equivalence tuple status semantics in runner outputs</name>
  <files>tests/run_tests.sh</files>
  <action>Standardize per-check tuple fields for verify-equivalence outputs (`arch`, `fixture_id`, `check`, `status`, `message`, `log_path`) and ensure repeated runs serialize equivalent status structures for the same inputs.</action>
  <verify><automated>bash tests/run_tests.sh --mode verify-equivalence --arch x64 --artifacts-dir ci-artifacts/phase6-tuples</automated></verify>
  <done>Equivalent inputs produce stable machine-readable tuple status output without schema drift.</done>
</task>

<task type="auto">
  <name>Task 3: Document deterministic equivalence scope and rerun expectations</name>
  <files>tests/README.md</files>
  <action>Update test workflow documentation so maintainers can reproduce deterministic verify-equivalence runs and understand representative-scope invariants before modifying manifest entries.</action>
  <verify><automated>rg -n "verify-equivalence|representative|manifest|deterministic" tests/README.md</automated></verify>
  <done>Contributor docs clearly define deterministic equivalence run path and representative governance constraints.</done>
</task>

</tasks>

<verification>
Validate that representative verify-equivalence runs emit deterministic tuple statuses across repeated invocations and retain explicit manifest-governed scope.
</verification>

<success_criteria>
- Representative fixture ordering is deterministic and manifest-driven
- Equivalence results emit stable tuple semantics
- Documentation explains deterministic rerun behavior and scope governance
</success_criteria>

<output>
After completion, create `.planning/phases/06-equivalence-gate-determinism-and-triage/06-01-SUMMARY.md`
</output>
