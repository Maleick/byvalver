fix: Critical bug fixes for ARM/ARM64 cross-architecture support (v4.0.1)

PROBLEM STATEMENT
=================

Code review of the v4.0 cross-architecture implementation identified several bugs
and code quality issues that could cause incorrect behavior or confusion when
processing ARM/ARM64 shellcode:

1. ARM64 `can_handle` logic was inverted - pass-through strategy returned true for
   instructions WITH bad bytes instead of clean instructions
2. ARM SUB instruction encoding used wrong opcode (0xE0400000 instead of 0xE2400000)
3. #include directives placed inside function body (unconventional, potential issues)
4. No warnings for experimental ARM/ARM64 support
5. No detection of potential architecture mismatch

SOLUTION
========

Implemented targeted fixes for all identified issues while maintaining backward
compatibility and clean build status.

CHANGES MADE
============

1. **Fixed ARM64 can_handle Logic** (src/arm64_strategies.c:17-22)
   - BEFORE: `return !is_bad_byte_free_buffer(...)` - returned true when BAD bytes present
   - AFTER:  `return is_bad_byte_free_buffer(...)` - returns true when instruction is CLEAN
   - Impact: ARM64 pass-through strategy now correctly handles clean instructions only

2. **Fixed ARM SUB Instruction Encoding** (src/arm_strategies.c:199-202)
   - BEFORE: `0xE0400000` - incorrect (I=0, opcode=EOR)
   - AFTER:  `0xE2400000` - correct (I=1, opcode=SUB=0x2)
   - Encoding breakdown:
     - Bits 31-28: 1110 (0xE = AL condition)
     - Bit 25: 1 (I = immediate operand)
     - Bits 24-21: 0010 (SUB opcode = 0x2)
     - Bit 20: 0 (S = don't set flags)
   - Updated comment to correctly document the encoding

3. **Moved Includes to File Scope** (src/strategy_registry.c:65-66)
   - BEFORE: `#include "arm_strategies.h"` inside `init_strategies()` function body
   - AFTER: Includes at file scope with other headers
   - Removed duplicate includes from inside conditional blocks
   - Follows C best practices for header inclusion

4. **Added Experimental Architecture Warnings** (src/main.c:193-205)
   - ARM: "WARNING: ARM support is EXPERIMENTAL - Only 7 core strategies implemented"
   - ARM64: "WARNING: ARM64 support is EXPERIMENTAL - Only basic pass-through strategies"
   - Advises users to use simpler bad-byte profiles for ARM

5. **Added Architecture Mismatch Detection** (src/main.c:207-237)
   - Heuristic checks for common x86/x64 patterns (PUSH EBP, REX.W prefix, SUB ESP)
   - Heuristic checks for ARM patterns (4-byte alignment, condition code in MSB)
   - Warns user if shellcode appears to be wrong architecture
   - Non-blocking warning - processing continues but user is informed

6. **Version Bump** (src/cli.h:18-22)
   - Updated from v4.0.0 to v4.0.1
   - Updated version string constant

7. **Documentation Updates** (README.md)
   - Added v4.0.1 bug fixes section in overview
   - Updated cross-architecture notes with warning information
   - Documented architecture mismatch detection feature

FILES CHANGED
=============

Modified Files (5):
- src/arm64_strategies.c: Fixed can_handle boolean logic
- src/arm_strategies.c: Fixed ARM SUB instruction encoding
- src/strategy_registry.c: Moved includes to file scope
- src/main.c: Added experimental warnings and mismatch detection
- src/cli.h: Version bump to 4.0.1
- README.md: Updated documentation with v4.0.1 changes

TECHNICAL DETAILS
=================

ARM SUB Encoding Fix:
--------------------
ARM data processing instruction format (32-bit):
```
31-28: Condition (0xE = AL = always execute)
27-26: 00 (data processing)
   25: I (1 = immediate operand, 0 = register)
24-21: Opcode (0010 = SUB, 0100 = ADD, 1111 = MVN, etc.)
   20: S (1 = set flags, 0 = don't set)
19-16: Rn (first operand register)
15-12: Rd (destination register)
 11-0: Operand2 (shifter operand / immediate)

SUB Rd, Rn, #imm encoding:
1110 0010 0100 NNNN DDDD iiii iiii iiii = 0xE24_____
```

ARM64 can_handle Fix:
--------------------
Pass-through strategies should only handle instructions that are ALREADY clean
(no bad bytes). The `is_bad_byte_free_buffer()` function returns:
- true: if buffer contains NO bad bytes (clean)
- false: if buffer contains ANY bad bytes

For pass-through: `can_handle` should return true when instruction is clean,
so we use `is_bad_byte_free_buffer()` directly without negation.

Architecture Mismatch Heuristics:
--------------------------------
x86/x64 indicators:
- 0x55: PUSH EBP/RBP (common function prologue)
- 0x48: REX.W prefix (x64 64-bit operand)
- 0x83 0xEC: SUB ESP, imm8 (stack allocation)

ARM indicators:
- File size divisible by 4 (ARM instructions are 4 bytes)
- Condition code 0xE in MSB of first instruction (AL = always)

IMPACT
======

Bug Severity Assessment:
-----------------------
- ARM64 can_handle: HIGH - would cause incorrect strategy selection
- ARM SUB encoding: HIGH - would generate incorrect machine code
- Include placement: LOW - code style issue, worked but unconventional
- Missing warnings: MEDIUM - user experience improvement
- Missing detection: LOW - convenience feature

Risk Assessment:
---------------
- x86/x64 processing: NO CHANGE - fully backward compatible
- ARM processing: IMPROVED - correct SUB encoding
- ARM64 processing: IMPROVED - correct pass-through behavior

TESTING
=======

Build Verification:
- make clean && make: SUCCESS (0 errors)
- All modified files compile without warnings
- No breaking changes to existing functionality

Manual Testing:
- ARM SUB encoding verified against ARM Architecture Reference Manual
- ARM64 can_handle logic verified with test cases
- Warning messages display correctly for ARM/ARM64
- Mismatch detection triggers appropriately

CONCLUSION
==========

v4.0.1 addresses critical bugs in the ARM/ARM64 cross-architecture support
introduced in v4.0. The ARM SUB encoding fix ensures correct machine code
generation, and the ARM64 can_handle fix ensures correct strategy selection.

Additional improvements include user-facing warnings for experimental features
and basic architecture mismatch detection to help users avoid configuration
errors.

All fixes maintain full backward compatibility with existing x86/x64 usage.

VERSION
=======

BYVALVER v4.0.1 (2026-01-13)

Critical bug fixes for cross-architecture support.
