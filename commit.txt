ENHANCEMENT: Add 4 strategic null-elimination modules to fill critical gaps in BYVALVER

## Summary

This commit addresses 4 critical gaps in BYVALVER's null-byte elimination capabilities by implementing sophisticated new strategies. The additions include: Enhanced PEB API Resolution, Conditional Jump Displacement Optimization, Register Allocation Strategies, and LEA Displacement Optimization to handle real-world shellcode patterns that were previously not optimally processed. All new strategies use appropriate priority levels to avoid interfering with critical Windows API strategies.

## Problem

BYVALVER had several gaps in its null-elimination strategy coverage:
1. PEB traversal and API resolution patterns with null-byte displacements weren't handled optimally
2. Conditional jump displacement patterns with nulls weren't addressed
3. Register allocation for null-byte avoidance was not implemented
4. LEA instruction displacement patterns weren't properly optimized

These gaps resulted in suboptimal transformation of shellcode patterns commonly found in real-world Windows exploits, potentially leaving null bytes unhandled.

## Solution

### Gap #1: Enhanced PEB API Resolution Strategies
- **Files:** `src/peb_api_resolution_strategies.c/h`
- **Strategies Added:**
  - Enhanced PEB Traversal Strategy (priority 88): Handles MOV operations with PEB offset displacements containing nulls
  - Hash-Based Resolution Strategy (priority 89): Handles CMP operations with function name comparisons containing null bytes  
  - PEB Conditional Jump Strategy (priority 87): Handles jumps in PEB traversal loops with null displacement bytes
- **Implementation:** Uses register arithmetic to avoid null-byte displacements in PEB traversal instructions like `mov eax, [ebx + 0x3c]`
- **Priority:** Set to 87-89 range to complement, not compete with, critical Windows API strategies

### Gap #2: Conditional Jump Displacement Strategies
- **Files:** `src/conditional_jump_displacement_strategies.c/h` 
- **Strategies Added:**
  - Conditional Jump Displacement Strategy (priority 85): Handles conditional jumps with null-byte displacement fields
  - Short Conditional Jump with Nulls Strategy (priority 82): Handles short conditional jumps with problematic encodings
  - Conditional Jump Alternative Strategy (priority 84): Alternative conditional jump patterns to avoid displacement nulls
- **Implementation:** Converts near conditional jumps with null displacements to alternative patterns using short jumps
- **Priority:** Set to 82-85 range to focus on displacement issues without interfering with critical jumps

### Gap #3: Register Allocation Strategies
- **Files:** `src/register_allocation_strategies.c/h`
- **Strategies Added:**
  - Register Remap Nulls Strategy (priority 75): Handles register usage that creates null bytes in encoding
  - MOV Register Remap Strategy (priority 78): Specific MOV register remapping to avoid addressing nulls
  - Contextual Register Swap Strategy (priority 72): Context-aware register swapping to avoid nulls
- **Implementation:** Uses alternative registers to avoid problematic addressing modes like EBP/R13 with zero displacement
- **Priority:** Set to 72-78 range to handle general register allocation without competing with specialized strategies

### Gap #4: LEA Displacement Optimization Strategies
- **Files:** `src/lea_displacement_optimization_strategies.c/h`
- **Strategies Added:**
  - LEA Displacement Nulls Strategy (priority 82): Handles LEA with null-byte displacements
  - LEA Problematic Encoding Strategy (priority 81): Handles LEA with EBP/R13 addressing requiring null displacement bytes
- **Implementation:** Converts LEA instructions with problematic displacements to register arithmetic sequences
- **Priority:** Set to 81-82 range to handle LEA displacement patterns specifically

### Strategic Prioritization

New priorities were carefully assigned to avoid disrupting existing high-priority Windows API strategies:
- **PEB strategies:** 87-89 (below syscall and critical Windows strategies)
- **Conditional jump strategies:** 82-85 (complement existing jump strategies)
- **Register allocation strategies:** 72-78 (general optimization level)
- **LEA strategies:** 81-82 (address LEA displacement specifically)

## Technical Implementation

### New Strategy Patterns Implemented

#### 1. PEB Traversal Null Handling
```c
// For: mov eax, [ebx + 0x3c] where 0x3c contains nulls
// Becomes: MOV temp_reg, base_reg; ADD temp_reg, disp (null-free); MOV dst_reg, [temp_reg]
generate_mov_reg_imm(b, &(cs_insn){...});  // Copy base
generate_op_reg_imm(b, &(cs_insn){...});   // Add displacement without nulls
// Load from calculated address
```

#### 2. Conditional Jump Displacement Alternatives
```c
// For: jz target_with_nulls in displacement
// Becomes: inverse_condition short_jump; jmp target; short_jump_label:
// Uses J!cc short_over; JMP target; short_over:
```

#### 3. Register Remapping to Avoid Nulls
```c
// For: mov reg, [EBP] which requires 00 displacement byte
// Becomes: mov reg, EBP (avoiding problematic addressing)
// Or: use alternative register addressing modes
```

#### 4. LEA Displacement Handling
```c
// For: lea reg, [base + disp_with_nulls]
// Becomes: MOV reg, base_reg; ADD reg, disp (constructed without nulls)
```

### Integration with Existing Architecture
- All new strategies follow BYVALVER's strategy pattern interface
- Proper registration in `strategy_registry.c` with appropriate priorities
- Compatible with ML-powered strategy selection
- Maintain backward compatibility with existing functionality

## Performance Impact

### New Capabilities:
- ✅ Enhanced PEB-based API resolution with null displacement handling
- ✅ Conditional jump displacement optimization for null-elimination  
- ✅ Dynamic register allocation to avoid null-byte patterns
- ✅ LEA instruction optimization for displacement null-elimination
- ✅ Improved processing of complex Windows shellcode patterns
- ✅ Better preservation of functional equivalence in complex cases
- ✅ More comprehensive coverage of shellcode techniques

### Compatibility:
- ✅ All existing functionality preserved
- ✅ No breaking changes to existing APIs
- ✅ Compatible with ML-powered prioritization
- ✅ Appropriate priority levels to avoid conflicts
- ✅ No performance regression in existing capabilities

## Files Changed

### New Implementation Files
- Added `src/peb_api_resolution_strategies.c/h` - Enhanced PEB API resolution
- Added `src/conditional_jump_displacement_strategies.c/h` - Conditional jump displacement handling
- Added `src/register_allocation_strategies.c/h` - Register allocation strategies
- Added `src/lea_displacement_optimization_strategies.c/h` - LEA displacement optimization

### Updated Implementation Files
- Updated `src/strategy_registry.c` - New strategy registrations with appropriate priorities
- Updated documentation in README.md and DNULL_STRATS.md

## Verification

- ✅ All new strategies compile without warnings
- ✅ Project builds successfully with new implementations
- ✅ Appropriate priority levels assigned (not disrupting critical strategies)
- ✅ New strategies integrated into registry system properly
- ✅ No conflicts with existing strategy implementations
- ✅ Documentation updated to reflect new capabilities
- ✅ Test execution confirms proper functionality

## Impact

This enhancement significantly improves BYVALVER's capability to handle complex shellcode patterns by:
1. Addressing 4 critical strategy gaps identified in real shellcode analysis
2. Providing sophisticated approaches for complex Windows shellcode patterns
3. Maintaining appropriate priority levels for strategic compatibility
4. Enhancing null-byte elimination for advanced shellcode techniques
5. Improving overall shellcode transformation completeness
6. Better handling of PEB traversal and API resolution patterns
7. More robust handling of control flow and addressing mode transformations